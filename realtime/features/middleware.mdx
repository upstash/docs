---
title: "Middleware & Authentication"
---

Protect your realtime endpoints with custom authentication and authorization logic.

## Basic Middleware

Add middleware to your realtime endpoint:

```typescript title="app/api/realtime/route.ts"
import { handle } from "@upstash/realtime"
import { realtime } from "@/lib/realtime"
import { currentUser } from "@/auth"

export const GET = handle({
  realtime,
  middleware: async ({ request, channel }) => {
    const user = await currentUser(request)

    if (!user) {
      return new Response("Unauthorized", { status: 401 })
    }
  },
})
```

## Middleware API

The middleware function receives:

<ParamField path="request" type="Request">
  The incoming HTTP Request object
</ParamField>

<ParamField path="channel" type="string" default="default">
  The channel the client is attempting to connect to
</ParamField>

<ResponseField name="return">
  - Return `undefined` or nothing to allow the connection
  - Return a `Response` object to block the connection with a custom error
</ResponseField>

## Authentication Patterns

<AccordionGroup>
  <Accordion title="Session-Based Auth">
    Verify user sessions before allowing connections:

    ```typescript
    import { getSession } from "@/auth"

    export const GET = handle({
      realtime,
      middleware: async ({ request }) => {
        const session = await getSession(request)

        if (!session?.user) {
          return new Response("Please sign in", { status: 401 })
        }
      },
    })
    ```
  </Accordion>

  <Accordion title="Token-Based Auth">
    Validate JWT tokens or API keys:

    ```typescript
    import { verifyToken } from "@/auth"

    export const GET = handle({
      realtime,
      middleware: async ({ request }) => {
        const token = request.headers.get("Authorization")?.replace("Bearer ", "")

        if (!token) {
          return new Response("Missing token", { status: 401 })
        }

        const payload = await verifyToken(token)
        if (!payload) {
          return new Response("Invalid token", { status: 401 })
        }
      },
    })
    ```
  </Accordion>

  <Accordion title="Channel Permissions">
    Verify users can access specific channels:

    ```typescript
    export const GET = handle({
      realtime,
      middleware: async ({ request, channel }) => {
        const user = await currentUser(request)

        if (channel === user.id) {
          return
        }

        if (channel !== user.id) {
          return new Response("You can only access your own channel", { status: 403 })
        }
      },
    })
    ```
  </Accordion>

  <Accordion title="Role-Based Access">
    Control access based on user roles:

    ```typescript
    export const GET = handle({
      realtime,
      middleware: async ({ request, channel }) => {
        const user = await currentUser(request)

        if (channel?.startsWith("admin-") && user.role !== "admin") {
          return new Response("Admin access required", { status: 403 })
        }

        if (channel?.startsWith("team-")) {
          const teamId = channel.replace("team-", "")
          const isMember = await checkTeamMembership(user.id, teamId)

          if (!isMember) {
            return new Response("Not a team member", { status: 403 })
          }
        }
      },
    })
    ```
  </Accordion>
</AccordionGroup>

## Custom Error Messages

Return detailed error responses:

```typescript
export const GET = handle({
  realtime,
  middleware: async ({ request, channel }) => {
    const user = await currentUser(request)

    if (!user) {
      return new Response(
        JSON.stringify({ error: "Authentication required" }),
        {
          status: 401,
          headers: { "Content-Type": "application/json" },
        }
      )
    }

    if (!user.isVerified) {
      return new Response(
        JSON.stringify({ error: "Please verify your email" }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      )
    }
  },
})
```

## Rate Limiting

Combine with Upstash Ratelimit for connection throttling:

```typescript
import { Ratelimit } from "@upstash/ratelimit"
import { redis } from "@/lib/redis"

const ratelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(10, "60 s"),
})

export const GET = handle({
  realtime,
  middleware: async ({ request }) => {
    const ip = request.headers.get("x-forwarded-for") ?? "anonymous"
    const { success } = await ratelimit.limit(ip)

    if (!success) {
      return new Response("Too many connections", { status: 429 })
    }
  },
})
```

## Multi-Tenant Applications

To make sure users only access their organization's data:

```typescript
export const GET = handle({
  realtime,
  middleware: async ({ request, channel }) => {
    const user = await currentUser(request)
    const orgId = channel?.split("-")[0]

    if (orgId !== user.organizationId) {
      return new Response("Access denied", { status: 403 })
    }
  },
})
```

