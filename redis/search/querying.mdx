---
title: Querying
---

Queries are JSON strings that describe what documents to find. The simplest form specifies field-value pairs:

The most common way to search is by providing field values directly.
This approach is recommended for most use cases and provides intelligent matching behavior.

<Tabs>

<Tab title="TypeScript">
```ts
// Search for a term in a specific field
await index.query({
  filter: {
    name: "headphones",
  },
});

// Search across multiple fields (implicit AND)
await index.query({
  filter: {
    name: "wireless",
    category: "electronics",
  },
});

// Search with exact values for non-text fields
await index.query({
  filter: {
    inStock: true,
    price: 199.99,
  },
});
```
</Tab>

<Tab title="Redis CLI">
```bash
# Search for a term in a specific field
SEARCH.QUERY products '{"name": "headphones"}'

# Search across multiple fields (implicit AND)
SEARCH.QUERY products '{"name": "wireless", "category": "electronics"}'

# Search with exact values for non-text fields
SEARCH.QUERY products '{"inStock": true, "price": 199.99}'
```
</Tab>

</Tabs>

### Smart Matching for Text Fields

When you provide a value directly to a text field (without explicit operators),
the search engine applies [smart matching](./query-operators/field-operators/smart-matching):

- **Single-word values**: Performs a term search, matching the word against tokens in the field.
- **Multi-word values**: Combines phrase matching, term matching, and fuzzy matching with
  different boost weights to rank exact phrases highest while still finding partial matches.
- **Double-quoted phrases**: Forces exact phrase matching (e.g., `"\"noise cancelling\""` matches
  only those words adjacent and in order).

For more control, use explicit operators like [`$phrase`](./query-operators/field-operators/phrase),
[`$fuzzy`](./query-operators/field-operators/fuzzy), or [`$contains`](./query-operators/field-operators/contains).

### Query Options

The `SEARCH.QUERY` command supports several options to control result format and ordering.

#### Pagination with Limit and Offset

Limit controls how many results to return.
Offset controls how many results to skip.

Used together, these options provide a way to do pagination.

<Tabs>

<Tab title="TypeScript">
```ts
// Page 1: first 10 results (with optional offset)
const page1 = await index.query({
  filter: {
    description: "wireless",
  },
  limit: 10,
});

// Page 2: results 11-20
const page2 = await index.query({
  filter: {
    description: "wireless",
  },
  limit: 10,
  offset: 10,
});

// Page 3: results 21-30
const page3 = await index.query({
  filter: {
    description: "wireless",
  },
  limit: 10,
  offset: 20,
});
```
</Tab>

<Tab title="Redis CLI">
```bash
# Page 1: first 10 results (with optional offset)
SEARCH.QUERY products '{"description": "wireless"}' LIMIT 10

# Page 2: results 11-20
SEARCH.QUERY products '{"description": "wireless"}' LIMIT 10 OFFSET 10

# Page 3: results 21-30
SEARCH.QUERY products '{"description": "wireless"}' LIMIT 10 OFFSET 20
```
</Tab>

</Tabs>

#### Sorting Results

Normally, search results are sorted in descending order of query relevance.

It is possible to override this, and sort the results by a certain field
in ascending or descending order.

Only fields defined as `FAST` in the schema can be used as the sort field.

When using `SORTBY`, the score in results reflects the sort field's value rather than relevance.

<Tabs>

<Tab title="TypeScript">
```ts
// Sort by price, cheapest first
await products.query({
  filter: {
    category: "electronics",
  },
  orderBy: {
    price: "ASC",
  },
});

// Sort by date, newest first
await articles.query({
  filter: {
    author: "john",
  },
  orderBy: {
    publishedAt: "DESC",
  },
});

// Sort by rating, highest first, which can be combined with LIMIT and OFFSET
await products.query({
  filter: {
    inStock: true,
  },
  orderBy: {
    rating: "DESC",
  },
  limit: 5,
});
```
</Tab>

<Tab title="Redis CLI">
```bash
# Sort by price, cheapest first
SEARCH.QUERY products '{"category": "electronics"}' SORTBY price ASC

# Sort by date, newest first
SEARCH.QUERY articles '{"author": "john"}' SORTBY publishedAt DESC

# Sort by rating, highest first, which can be combined with LIMIT and OFFSET
SEARCH.QUERY products '{"inStock": true}' SORTBY rating DESC LIMIT 5
```
</Tab>

</Tabs>

#### Controlling Output

By default, search results include document key, relevance score, and the contents of the document
(including the non-indexed fields).

For JSON and string indexes, that means the stored JSON objects as whole. For hash indexes, it means
all fields and values.

It is possible to get only document keys and relevance scores using `NOCONTENT`.

<Tabs>

<Tab title="TypeScript">
```ts
// Return only keys and scores
await products.query({
  filter: {
    name: "headphones",
  },
  select: {},
});
```
</Tab>

<Tab title="Redis CLI">
```bash
# Return only keys and scores
SEARCH.QUERY products '{"name": "headphones"}' NOCONTENT
```
</Tab>

</Tabs>

It is also possible to select only the specified fields of the documents, whether they are indexed or not.

<Tabs>

<Tab title="TypeScript">
```ts
// Return specific fields only
await products.query({
  filter: {
    name: "headphones",
  },
  select: {
    name: true,
    price: true,
  },
});
```
</Tab>

<Tab title="Redis CLI">
```bash
# Return specific fields only
SEARCH.QUERY products '{"name": "headphones"}' RETURN 2 name price
```
</Tab>

</Tabs>

<Note>
When using [aliased fields](/redis/search/schema-definition#aliased-fields),
use the **actual document field name** (not the alias) when selecting fields to return.
This is because aliasing happens at the index level and does not modify the underlying documents.
</Note>

#### Highlighting

Highlighting allows you to see why a document matched the query by marking the matching portions of the document's fields.

By default, `<em>` and `</em>` are used as the highlight tags.

<Tabs>

<Tab title="TypeScript">
```ts
// Highlight matching terms
await products.query({
  filter: {
    description: "wireless noise cancelling",
  },
  highlight: {
    fields: ["description"],
  },
});

// Custom open and close highlight tags
await products.query({
  filter: {
    description: "wireless",
  },
  highlight: {
    fields: ["description"],
    preTag: "!!",
    postTag: "**",
  },
});
```
</Tab>

<Tab title="Redis CLI">
```bash
# Highlight matching terms
SEARCH.QUERY products '{"description": "wireless noise cancelling"}' HIGHLIGHT FIELDS 1 description

# Custom open and close highlight tags
SEARCH.QUERY products '{"description": "wireless"}' HIGHLIGHT FIELDS 1 description TAGS !! **
```
</Tab>

</Tabs>

Note that, highlighting only works for operators that resolve to terms, such as term or
phrase queries.

<Note>
When using [aliased fields](/redis/search/schema-definition#aliased-fields),
use the **alias name** (not the actual document field name) when specifying fields to highlight.
The highlighting feature works with indexed field names, which are the aliases.
</Note>
